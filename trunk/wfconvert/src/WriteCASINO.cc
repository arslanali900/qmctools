#include "OrbitalSetClass.h"
#include <einspline/bspline.h>

void
OrbitalSetClass::MakeRealSpaceBlip (int spin, int ki, int band)
{
  CellClass &cell = WriteSuper ? SuperCell : PrimCell;
  FFTBox &FFT = cell.FFT;
  TinyVector<Array<OrbitalClass*,2>,2> &orbs = 
    WriteSuper ? SuperOrbitals : PrimOrbitals;

  cell.SetupFFT();

  int Nx, Ny, Nz; // FFT box size
  FFT.GetDims (Nx, Ny, Nz);
  double nxInv = 1.0/(double)Nx;
  double nyInv = 1.0/(double)Ny;
  double nzInv = 1.0/(double)Nz;

  zVec scaledCoefs(orbs[spin](0,0)->GetCoefs().size());
  FFT.kBox = complex<double>();


  if (ShiftOrbitals) 
    cerr << "ShiftOrbitals not yet implemented.\n"; // do something different
  else {
    if (band < NewOrbCoefs[spin].extent(1)) {
      FFT.kBox = complex<double>();
      for (int bi=0; bi<NewOrbCoefs[spin].extent(2); bi++) {
	OrbitalClass &orb = *orbs[spin](ki,bi);
	scaledCoefs = orb.GetCoefs();
	for (int i=0; i<scaledCoefs.size(); i++) {
	  Vec3 G = cell.Lattice.k2Twist(FFT.GVecs(i)+orb.GetGshift());
	  G = 2.0*M_PI * G;
	  G[0] *= nxInv;    G[1] *= nyInv;     G[2] *= nzInv;
	  double gamma = 1.0;
	  if (fabs(G[0]) > 1.0e-12)
	    gamma *= (3.0/(G[0]*G[0]*G[0]*G[0])*(3.0 - 4.0*cos(G[0]) + cos(2.0*G[0])));
	  else
	    gamma *= 1.5;
	  if (fabs(G[1]) > 1.0e-12)
	    gamma *= (3.0/(G[1]*G[1]*G[1]*G[1])*(3.0 - 4.0*cos(G[1]) + cos(2.0*G[1])));
	  else
	    gamma *= 1.5;
	  if (fabs(G[2]) > 1.0e-12)
	    gamma *= (3.0/(G[2]*G[2]*G[2]*G[2])*(3.0 - 4.0*cos(G[2]) + cos(2.0*G[2])));
	  else
	    gamma *= 1.5;
	  scaledCoefs(i) = scaledCoefs(i)/gamma;
	}
	orbs[spin](ki,bi)->AddToFFTBox(scaledCoefs);
      }
    }
    else {
      OrbitalClass &orb = *orbs[spin](ki,band);
      scaledCoefs = orb.GetCoefs();
      for (int i=0; i<scaledCoefs.size(); i++) {
	Vec3 G = cell.Lattice.k2Twist(FFT.GVecs(i)+orb.GetGshift());
	G = 2.0*M_PI * G;
	G[0] *= nxInv;    G[1] *= nyInv;     G[2] *= nzInv;
	double gamma = 1.0;
	if (fabs(G[0]) > 1.0e-12)
	  gamma *= (3.0/(G[0]*G[0]*G[0]*G[0])*(3.0 - 4.0*cos(G[0]) + cos(2.0*G[0])));
	else
	  gamma *= 1.5;
	if (fabs(G[1]) > 1.0e-12)
	  gamma *= (3.0/(G[1]*G[1]*G[1]*G[1])*(3.0 - 4.0*cos(G[1]) + cos(2.0*G[1])));
	else
	  gamma *= 1.5;
	if (fabs(G[2]) > 1.0e-12)
	  gamma *= (3.0/(G[2]*G[2]*G[2]*G[2])*(3.0 - 4.0*cos(G[2]) + cos(2.0*G[2])));
	else
	  gamma *= 1.5;
	scaledCoefs(i) = scaledCoefs(i)/gamma;
      }
    }
    orbs[spin](ki,band)->PutInFFTBox(scaledCoefs);
  }
  FFT.k2r();
  // Now, make as real as possible
  complex<double> avg(0.0, 0.0);
  for (int ix=0; ix<Nx; ix++)  
    for (int iy=0; iy<Ny; iy++)
      for (int iz=0; iz<Nz; iz++)
	avg += FFT.rBox(ix,iy,iz);
  complex<double> phase = conj(avg)/sqrt(norm(avg));
  for (int ix=0; ix<Nx; ix++)  
    for (int iy=0; iy<Ny; iy++)
      for (int iz=0; iz<Nz; iz++)
	FFT.rBox(ix,iy,iz) *= phase;
}


void
OrbitalSetClass::MakeRealSpaceInterp (int spin, int ki, int band)
{
  int nx, ny, nz;
  complex<double> phase_rotation =
    MakeRealSpaceOrbital (spin, ki, band, ShiftOrbitals || Truncate);
  TinyVector<Array<OrbitalClass*,2>,2> &orbs = 
    WriteSuper ? SuperOrbitals : PrimOrbitals;
  vector<TinyVector<Array<OrbitalClass*,2>,2> > &firstOrder = 
    WriteSuper && false ? SuperFirstOrder : PrimFirstOrder;
  CellClass &cell = WriteSuper ? SuperCell : PrimCell;
  FFTBox &FFT = cell.FFT;
  FFT.GetDims (nx, ny, nz);
  
  double wfnorm = 0.0;
  double vol = fabs(det(cell.Lattice.GetDirect()));
  double elemvol = vol/(nx*ny*nz);
  double prefactor = sqrt(1.0/(vol));
  OrbitalClass &orb = *orbs[spin](ki,band);
  
  BCtype_z xBC, yBC, zBC;
  xBC.lCode = xBC.rCode = PERIODIC;
  yBC.lCode = yBC.rCode = PERIODIC;
  zBC.lCode = zBC.rCode = PERIODIC;

  Ugrid x_grid, y_grid, z_grid;
  x_grid.start=0.0;  x_grid.end=1.0;  x_grid.num=nx;
  y_grid.start=0.0;  y_grid.end=1.0;  y_grid.num=ny;
  z_grid.start=0.0;  z_grid.end=1.0;  z_grid.num=nz;

  FFT.rBox *= prefactor;
  
  UBspline_3d_z *spline = create_UBspline_3d_z 
    (x_grid, y_grid, z_grid, xBC, yBC, zBC, FFT.rBox.data());

  int xs = spline->x_stride;
  int ys = spline->y_stride;
  for (int ix=0; ix<nx; ix++)
    for (int iy=0; iy<ny; iy++)
      for (int iz=0; iz<nz; iz++) {
	int i = (ix+1)%nx;
	int j = (iy+1)%ny;
	int k = (iz+1)%nz;
	FFT.rBox(ix,iy,iz) = spline->coefs[i*xs + j*ys + k];
      }

  destroy_Bspline (spline);
}


void
OrbitalSetClass::WriteCasinoHeader(FILE *fout)
{
  CellClass &cell = WriteSuper ? SuperCell : PrimCell;
  double volRatio = SuperCell.Lattice.GetVolume() / PrimCell.Lattice.GetVolume();
  double factor = WriteSuper ? volRatio : 1.0;


  fprintf (fout, "QMC trial wave function file for CASINO generated by wfconvert\n\n");
  fprintf (fout, "BASIC INFO\n----------\n");
  fprintf (fout, "Generated by:\n");
  fprintf (fout, "%s\n", GeneratedBy.c_str());
  fprintf (fout, "Method:\n");
  fprintf (fout, " %s\n", Method.c_str());
  fprintf (fout, "DFT Functional:\n");
  fprintf (fout, "%s\n", Functional.c_str());
  fprintf (fout, "Pseudopotential (of first atom type)\n");
  fprintf (fout, "%s\n", Pseudopotential.c_str());
  fprintf (fout, "Plane wave cutoff (au)\n");
  fprintf (fout, "%8.3f\n", ECut);
  fprintf (fout, "Spin polarized:\n");
  fprintf (fout, "%s\n", SpinPolarized ? ".true." : ".false.");
  fprintf (fout, "Total energy (au per primitive cell)\n");
  fprintf (fout, "%18.14f\n", factor*TotalEnergy);
  fprintf (fout, "Kinetic energy\n");
  fprintf (fout, " %18.14f\n", factor*KineticEnergy);
  fprintf (fout, "Local potential energy (Local pseudopotential energy eei + pseudopotential core-core energy eii)\n");
  fprintf (fout, " %18.14f\n", factor*LocalPotEnergy);
  fprintf (fout, "Non-local potential energy\n");
  fprintf (fout, " %18.14f\n", factor*NonlocalEnergy);
  fprintf (fout, "Electron-electron energy (Hartree Energy + Exchange-Correlation Energy)\n");
  fprintf (fout, " %18.14f\n", factor*eeEnergy);
  fprintf (fout, "Ion-ion energy\n");
  fprintf (fout, " %18.14f\n", factor*IonIonEnergy);
  fprintf (fout, "Number of electrons per primitive cell\n");
  fprintf (fout, "  %d\n\n", NumElectrons[0]+NumElectrons[1]);

  // Write the geometry
  fprintf (fout, "GEOMETRY\n--------\n");
  fprintf (fout, "Number of atoms per primitive cell\n");
  fprintf (fout, "  %d\n", cell.IonPos.size());
  fprintf (fout, "Atomic numbers and positions of atoms (au)\n");
  for (int i=0; i<cell.IonPos.size(); i++) 
    fprintf (fout, "%3d %16.14f %16.14f %16.14f\n", cell.AtomTypes(i), 
	     cell.IonPos(i)[0], cell.IonPos(i)[1], cell.IonPos(i)[2]);
  fprintf (fout, "Primitive lattice vectors (au)\n");
  Mat3 lattice = cell.Lattice.GetDirect();
  for (int i=0; i<3; i++)
    fprintf (fout, "%16.14f %16.14f %16.14f\n",
	     lattice(i,0), lattice(i,1), lattice(i,2));
  fprintf (fout, "\n");

  // Write the G-vectors
  fprintf (fout, "G VECTORS\n---------\n");
  fprintf (fout, "Number of G-vectors\n");
  if (WriteSuper)
    fprintf (fout, "   %d\n", SuperGVecs.size());
  else
    fprintf (fout, "   %d\n", cell.GVecs.size());
  fprintf (fout, "Gx Gy Gz (au)\n");
  // Invert the G-vectors again, since we inverted then when we read
  // them
  if (WriteSuper) 
    for (int i=0; i<SuperGVecs.size(); i++)
      fprintf (fout, "%20.16f  %20.16f  %20.16f\n",
	       -SuperGVecs(i)[0], -SuperGVecs(i)[1], -SuperGVecs(i)[2]);
  else
    for (int i=0; i<cell.GVecs.size(); i++)
      fprintf (fout, "%20.16f  %20.16f  %20.16f\n",
	       -cell.GVecs(i)[0], -cell.GVecs(i)[1], -cell.GVecs(i)[2]);
}

bool
OrbitalSetClass::WritePWFN (string fname)
{
  if (Comm.MyProc() != 0)
    return true;

  return true;
}

void
OrbitalSetClass::WriteBWFNOrb (FILE *fout, int spin, int ki, int band,
			       bool writeComplex)
{
  if (WriteInterp)
    MakeRealSpaceInterp (spin, ki, band);
  else
    MakeRealSpaceBlip (spin, ki, band);
  CellClass &cell = WriteSuper ? SuperCell : PrimCell;
  TinyVector<Array<OrbitalClass*,2>,2> &orbs =
    WriteSuper ? SuperOrbitals : PrimOrbitals;
  FFTBox &FFT = cell.FFT;

  int Nx, Ny, Nz;
  FFT.GetDims (Nx, Ny, Nz);
  Mat3 latticeInv = cell.Lattice.GetInverse();
  OrbitalClass &orb = *orbs[spin](ki, band);
  CenterClass &center = orb.GetCenter();
  double realNorm2 = 0.0; 
  double imagNorm2 = 0.0;

  if (&center != NULL) {
    int nx, ny, nz; // Truncated orbital size
    int ix, iy, iz;
    Vec3 bMag;
    bMag[0] = sqrt (latticeInv(0,0)*latticeInv(0,0) + latticeInv(0,1)*latticeInv(0,1) +
		    latticeInv(0,2)*latticeInv(0,2));
    bMag[1] = sqrt (latticeInv(1,0)*latticeInv(1,0) + latticeInv(1,1)*latticeInv(1,1) +
		    latticeInv(1,2)*latticeInv(1,2));
    bMag[2] = sqrt (latticeInv(2,0)*latticeInv(2,0) + latticeInv(2,1)*latticeInv(2,1) +
		    latticeInv(2,2)*latticeInv(2,2));
    Vec3 reducedCenter = cell.Lattice.r2u(center.r);
    ix = (int)floor (reducedCenter[0] * Nx);
    iy = (int)floor (reducedCenter[1] * Ny);
    iz = (int)floor (reducedCenter[2] * Nz);

    double outerRadius = center.Radius + center.SkinThickness;
    /// The +4 at the end is to try to resolve blip oscillation at the
    /// truncation boundary
    nx = (int)ceil (outerRadius*bMag[0]*Nx) /*+ 4*/;
    ny = (int)ceil (outerRadius*bMag[1]*Ny) /*+ 4*/;
    nz = (int)ceil (outerRadius*bMag[2]*Nz) /*+ 4*/;
    if (2*nx+4 > Nx)      nx = (Nx-4)/2;
    if (2*ny+4 > Ny)      ny = (Ny-4)/2;
    if (2*nz+4 > Nz)      nz = (Nz-4)/2;
    int n1x = ix-nx-1;    int n2x = ix+nx+2;
    int n1y = iy-ny-1;    int n2y = iy+ny+2;
    int n1z = iz-nz-1;    int n2z = iz+nz+2;
    fprintf (fout, "Start of grid; grid dimensions\n");
    fprintf (fout, "%d %d %d %d %d %d\n",
	     n1x, n1y, n1z, n2x-n1x+1, n2y-n1y+1, n2z-n1z+1);
    fprintf (fout, "Real blip coefficients for localized orbital\n");
    if (realNorm2 > imagNorm2) 
      for (int xi=n1x; xi<=n2x; xi++) {
	int ix = (xi+Nx)%Nx;
	for (int yi=n1y; yi<=n2y; yi++) {
	  int iy = (yi+Ny)%Ny;
	  for (int zi=n1z; zi<=n2z; zi++) {
	    int iz = (zi+Nz)%Nz;
	    // Removing phase factor for now
	    complex<double> wfVal = /* factor * */ FFT.rBox(ix,iy,iz);
	    fprintf (fout, "  %23.16e\n", wfVal.real());
	  }
	}
      }
    else 
      for (int xi=n1x; xi<=n2x; xi++) {
	int ix = (xi+Nx)%Nx;
	for (int yi=n1y; yi<=n2y; yi++) {
	  int iy = (yi+Ny)%Ny;
	  for (int zi=n1z; zi<=n2z; zi++) {
	    int iz = (zi+Nz)%Nz;
	    // Removing phase factor for now
	    complex<double> wfVal = /* factor * */ FFT.rBox(ix,iy,iz);
	    fprintf (fout, "  %23.16e\n", wfVal.imag());
	  }
	}
      }
  } // if (&center != NULL)
  else { // &center == NULL:  write extended orbital
    if (writeComplex) {
      fprintf (fout, "Complex blip coefficients for extended orbital\n");
      for (int ix=0; ix<Nx; ix++)
	for (int iy=0; iy<Ny; iy++)
	  for (int iz=0; iz<Nz; iz++)
	    fprintf (fout, "  (%23.16e, %23.16e)\n",
		     FFT.rBox(ix,iy,iz).real(), FFT.rBox(ix,iy,iz).imag());
    }
    else {
      fprintf (fout, "Real blip coefficients for extended orbital\n");
      for (int ix=0; ix<Nx; ix++)
	for (int iy=0; iy<Ny; iy++)
	  for (int iz=0; iz<Nz; iz++) {
	    realNorm2 += FFT.rBox(ix,iy,iz).real()*FFT.rBox(ix,iy,iz).real();
	    imagNorm2 += FFT.rBox(ix,iy,iz).imag()*FFT.rBox(ix,iy,iz).imag();
	  }
      if (realNorm2 > imagNorm2 && !WriteInterp) 
	for (int ix=0; ix<Nx; ix++)
	  for (int iy=0; iy<Ny; iy++)
	    for (int iz=0; iz<Nz; iz++) {
	      // Removing phase factor for now
	      complex<double> wfVal = /* factor * */ FFT.rBox(ix,iy,iz);
	      fprintf (fout, "  %23.16e\n", wfVal.real());
	      //	  fprintf (fout, "  %23.16e\n", FFT.rBox(ix,iy,iz).real());
	    }
      else
	for (int ix=0; ix<Nx; ix++)
	  for (int iy=0; iy<Ny; iy++)
	    for (int iz=0; iz<Nz; iz++) {
	      // Removing phase factor for now
	      complex<double> wfVal = /* factor * */ FFT.rBox(ix,iy,iz);
	      fprintf (fout, "  %23.16e\n", wfVal.imag());
	    }
    }
  }
}

bool
OrbitalSetClass::WriteBWFN (string fname, bool splitTwists)
{
  if (Comm.MyProc() != 0)
    return true;
  CellClass &cell = WriteSuper ? SuperCell : PrimCell;
  TinyVector<Array<OrbitalClass*,2>,2> &orbs =
    WriteSuper ? SuperOrbitals : PrimOrbitals;
  FFTBox &FFT = cell.FFT;

  if (Comm.MyProc() != 0)
    return true;

  cell.SetupFFT();

  // Write complex orbitals if not at the gamma point
  bool writeComplex = orbs[0].extent(0) > 1;
  Vec3 k0 = orbs[0](0,0)->Getk();
  writeComplex = writeComplex || (dot(k0,k0) > 1.0e-10);

  FILE *fout = fopen (fname.c_str(), "w");
  if (fout == NULL)
    return false;
  WriteCasinoHeader (fout);
  fprintf (fout, "Blip Grid\n");
  int nx, ny, nz;
  FFT.GetDims (nx, ny, nz);
  fprintf (fout, "%4d %4d %4d\n", nx, ny, nz);
  fprintf (fout, "\n");
  fprintf (fout, "WAVE FUNCTION\n-------------\n");
  fprintf (fout, "Number of k-points\n");
  int numk = orbs[0].extent(0);
  int numBands[2];
  numBands[0] = orbs[0].extent(1);
  numBands[1] = orbs[1].extent(1);
  fprintf (fout, "    %d\n", numk);
  for (int ki=0; ki < numk; ki++) {
    Vec3 k = orbs[0](ki,0)->Getk();
    // Flip the sign of the k-vectors back again when writing
    fprintf (fout, "k-point # ; # of bands (up spin/down spin) ; k-point coords (au)\n");
    fprintf (fout, "     %d     %d     %d  %20.15f %20.15f %20.15f\n",
	     ki+1, numBands[0], numBands[1], -k[0], -k[1], -k[2]);
    for (int spin=0; spin<2; spin++) {
      for (int band=0; band < numBands[spin]; band++) {
	fprintf (fout, "Band, spin, eigenvalue (au), localized\n");
	fprintf (fout, "    %3d    %3d    %20.16f %s\n", 
		 band+1, spin+1, orbs[spin](ki, band)->GetEigVal(),
		 &(orbs[spin](ki,band)->GetCenter())==NULL ? "F" : "T");
	WriteBWFNOrb (fout, spin, ki, band, writeComplex);
      }
    }
  }

  fclose(fout);
//   if (Localized) 
//     WriteCentres();
  return true;
}
