#include "PlaneWaveClass.h"
#include "ParserClass.h"
#include "ParseCommand.h"
#include <Common/Splines/ComplexMultiTricubicSpline.h>

inline complex<double> promote (complex<float> val)
{ return complex<double>(val.real(), val.imag()); }

inline complex<double> promote (complex<double> val)
{ return val; }

void
PlaneWaveSystem::WriteCasinoHeader(FILE *fout)
{
  CellClass &cell = WriteSuper ? SuperCell : PrimCell;

  fprintf (fout, "QMC trial wave function file for CASINO generated by wfconvert\n\n");
  fprintf (fout, "BASIC INFO\n----------\n");
  fprintf (fout, "Generated by:\n");
  fprintf (fout, "%s\n", GeneratedBy.c_str());
  fprintf (fout, "Method:\n");
  fprintf (fout, " %s\n", Method.c_str());
  fprintf (fout, "DFT Functional:\n");
  fprintf (fout, "%s\n", Functional.c_str());
  fprintf (fout, "Pseudopotential (of first atom type)\n");
  fprintf (fout, "%s\n", Pseudopotential.c_str());
  fprintf (fout, "Plane wave cutoff (au)\n");
  fprintf (fout, "%8.3f\n", ECut);
  fprintf (fout, "Spin polarized:\n");
  fprintf (fout, "%s\n", SpinPolarized ? ".true." : ".false.");
  fprintf (fout, "Total energy (au per primitive cell)\n");
  fprintf (fout, "%18.14f\n", TotalEnergy);
  fprintf (fout, "Kinetic energy\n");
  fprintf (fout, " %18.14f\n", KineticEnergy);
  fprintf (fout, "Local potential energy (Local pseudopotential energy eei + pseudopotential core-core energy eii)\n");
  fprintf (fout, " %18.14f\n", LocalPotEnergy);
  fprintf (fout, "Non-local potential energy\n");
  fprintf (fout, " %18.14f\n", NonlocalEnergy);
  fprintf (fout, "Electron-electron energy (Hartree Energy + Exchange-Correlation Energy)\n");
  fprintf (fout, " %18.14f\n", eeEnergy);
  fprintf (fout, "Ion-ion energy\n");
  fprintf (fout, " %18.14f\n", IonIonEnergy);
  fprintf (fout, "Number of electrons per primitive cell\n");
  fprintf (fout, "  %d\n\n", NumElectrons);

  // Write the geometry
  fprintf (fout, "GEOMETRY\n--------\n");
  fprintf (fout, "Number of atoms per primitive cell\n");
  fprintf (fout, "  %d\n", cell.IonPos.size());
  fprintf (fout, "Atomic numbers and positions of atoms (au)\n");
  for (int i=0; i<cell.IonPos.size(); i++) 
    fprintf (fout, "%3d %16.14f %16.14f %16.14f\n", cell.AtomTypes(i), 
	     cell.IonPos(i)[0], cell.IonPos(i)[1], cell.IonPos(i)[2]);
  fprintf (fout, "Primitive lattice vectors (au)\n");
  Mat3 lattice = cell.Lattice.GetDirect();
  for (int i=0; i<3; i++)
    fprintf (fout, "%16.14f %16.14f %16.14f\n",
	     lattice(i,0), lattice(i,1), lattice(i,2));
  fprintf (fout, "\n");

  // Write the G-vectors
  fprintf (fout, "G VECTORS\n---------\n");
  fprintf (fout, "Number of G-vectors\n");
  fprintf (fout, "   %d\n", cell.GVecs.size());
  fprintf (fout, "Gx Gy Gz (au)\n");
  // Invert the G-vectors again, since we inverted then when we read them
  for (int i=0; i<cell.GVecs.size(); i++)
    fprintf (fout, "%20.16f  %20.16f  %20.16f\n",
	     -cell.GVecs(i)[0], -cell.GVecs(i)[1], -cell.GVecs(i)[2]);
}

void
OrbitalClass::WriteBWFN (FILE *fout, bool writeComplex, bool writeSuper)
{
  CellClass &cell = writeSuper ? SuperCell : PrimCell;
  FFTBox &FFT = cell.FFT;
  Mat3 lattice    = FFT.GVecs.GetLattice();
  Mat3 latticeInv = FFT.GVecs.GetLatticeInv();
  int Nx, Ny, Nz; // FFT box size
  FFT.GetDims (Nx, Ny, Nz);

  if (Center != NULL) {
    Vec3 r = Center->r;
//     Vec3 reduced = latticeInv * Center->r;
//     reduced += Vec3 (0.5, 0.5, 0.5);
//     Vec3 rShift = reduced * lattice;
    Mat3 latticeInv = FFT.GVecs.GetLatticeInv();
    // This orbital is localized
    fprintf (fout, "Centre (au), inner cutoff radius (au), "
	     "outer cutoff radius (au) norm2, icut\n");
    // HACK HACK HACK:  the rShift is a check to see if this is the
    // problem in CASINO with localized functions.
    fprintf (fout, " %20.16f  %20.16f  %20.16f  %20.16f  "
	     "%20.16f  %20.16f %d\n",
	     r[0], r[1], r[2], 
	     Center->Radius, Center->Radius+Center->SkinThickness, -1.0, 1);
  }
  // Create blip coefficients
  zVec scaledCoefs (Coefs.size());
  double nxInv = 1.0/(double)Nx;
  double nyInv = 1.0/(double)Ny;
  double nzInv = 1.0/(double)Nz;
  Vec3 a[3];
  double realNorm2=0.0, imagNorm2 = 0.0;
  for (int i=0; i<scaledCoefs.size(); i++) {
    // Vec3 G = FFT.GVecs(i)*lattice;
    Vec3 G = cell.Lattice.k2Twist(FFT.GVecs(i));
    if (writeSuper)
      G += kPoint.GetSuperTwistInt();
    G = 2.0*M_PI * G;
    G[0] *= nxInv;    G[1] *= nyInv;     G[2] *= nzInv;
    double gamma = 1.0;
    if (fabs(G[0]) > 1.0e-12)
      gamma *= (3.0/(G[0]*G[0]*G[0]*G[0])*(3.0 - 4.0*cos(G[0]) + cos(2.0*G[0])));
    else
      gamma *= 1.5;
    if (fabs(G[1]) > 1.0e-12)
      gamma *= (3.0/(G[1]*G[1]*G[1]*G[1])*(3.0 - 4.0*cos(G[1]) + cos(2.0*G[1])));
    else
      gamma *= 1.5;
    if (fabs(G[2]) > 1.0e-12)
      gamma *= (3.0/(G[2]*G[2]*G[2]*G[2])*(3.0 - 4.0*cos(G[2]) + cos(2.0*G[2])));
    else
      gamma *= 1.5;
    
    realNorm2 += Coefs(i).real()*Coefs(i).real();
    imagNorm2 += Coefs(i).imag()*Coefs(i).imag();
    scaledCoefs(i) = /* 3.375* */ Coefs(i)/gamma;
  }

  kPoint.PutzVec(scaledCoefs, FFT, writeSuper);
  //FFT.PutkVec(scaledCoefs);
  FFT.k2r();
  // Now, determine the phase that makes the orbital as real as
  // possible
  double maxRho = 0.0;
  complex<double> wfMax;
  for (int ix=0; ix<Nx; ix++)
    for (int iy=0; iy<Ny; iy++)
      for (int iz=0; iz<Nz; iz++) {
	double rho = norm(FFT.rBox(ix,iy,iz));
	if (rho > maxRho) {
	  maxRho = rho;
	  wfMax = FFT.rBox(ix,iy,iz);
	}
      }
  double phase = atan2 (wfMax.imag(), wfMax.real());
  complex<double> factor (cos(phase), -sin(phase));


  // Now the blip coefficients are in the FFT box
  if (Center != NULL) {
    int nx, ny, nz; // Truncated orbital size
    int ix, iy, iz;
    Vec3 bMag;
    bMag[0] = sqrt (latticeInv(0,0)*latticeInv(0,0) + latticeInv(0,1)*latticeInv(0,1) +
		    latticeInv(0,2)*latticeInv(0,2));
    bMag[1] = sqrt (latticeInv(1,0)*latticeInv(1,0) + latticeInv(1,1)*latticeInv(1,1) +
		    latticeInv(1,2)*latticeInv(1,2));
    bMag[2] = sqrt (latticeInv(2,0)*latticeInv(2,0) + latticeInv(2,1)*latticeInv(2,1) +
		    latticeInv(2,2)*latticeInv(2,2));
    Vec3 reducedCenter = latticeInv * Center->r;
    ix = (int)floor (reducedCenter[0] * Nx);
    iy = (int)floor (reducedCenter[1] * Ny);
    iz = (int)floor (reducedCenter[2] * Nz);

    double outerRadius = Center->Radius + Center->SkinThickness;
    /// The +4 at the end is to try to resolve blip oscillation at the
    /// truncation boundary
    nx = (int)ceil (outerRadius*bMag[0]*Nx) /*+ 4*/;
    ny = (int)ceil (outerRadius*bMag[1]*Ny) /*+ 4*/;
    nz = (int)ceil (outerRadius*bMag[2]*Nz) /*+ 4*/;
    if (2*nx+4 > Nx)      nx = (Nx-4)/2;
    if (2*ny+4 > Ny)      ny = (Ny-4)/2;
    if (2*nz+4 > Nz)      nz = (Nz-4)/2;
    int n1x = ix-nx-1;    int n2x = ix+nx+2;
    int n1y = iy-ny-1;    int n2y = iy+ny+2;
    int n1z = iz-nz-1;    int n2z = iz+nz+2;
    fprintf (fout, "Start of grid; grid dimensions\n");
    fprintf (fout, "%d %d %d %d %d %d\n",
	     n1x, n1y, n1z, n2x-n1x+1, n2y-n1y+1, n2z-n1z+1);
    fprintf (fout, "Real blip coefficients for localized orbital\n");
    if (realNorm2 > imagNorm2) 
      for (int xi=n1x; xi<=n2x; xi++) {
	int ix = (xi+Nx)%Nx;
	for (int yi=n1y; yi<=n2y; yi++) {
	  int iy = (yi+Ny)%Ny;
	  for (int zi=n1z; zi<=n2z; zi++) {
	    int iz = (zi+Nz)%Nz;
	    // Removing phase factor for now
	    complex<double> wfVal = /* factor * */ FFT.rBox(ix,iy,iz);
	    fprintf (fout, "  %23.16e\n", wfVal.real());
	  }
	}
      }
    else 
      for (int xi=n1x; xi<=n2x; xi++) {
	int ix = (xi+Nx)%Nx;
	for (int yi=n1y; yi<=n2y; yi++) {
	  int iy = (yi+Ny)%Ny;
	  for (int zi=n1z; zi<=n2z; zi++) {
	    int iz = (zi+Nz)%Nz;
	    // Removing phase factor for now
	    complex<double> wfVal = /* factor * */ FFT.rBox(ix,iy,iz);
	    fprintf (fout, "  %23.16e\n", wfVal.imag());
	  }
	}
      }
  }
  else if (writeComplex) {
    fprintf (fout, "Complex blip coefficients for extended orbital\n");
    /// Note, we need to take the conjugate of the real-space values
    /// to agrees with CASINO's convention for the FFTs.  Since we use
    /// the opposite sign convention for the FFTs, we conjugate when
    /// we read the pwfn data file.  We must also then conjugate when
    /// we write the bwfn file.
    /// This is no longer true, since we now just flip the sign of the
    /// G-vectors and k-vectors
    for (int ix=0; ix<Nx; ix++)
      for (int iy=0; iy<Ny; iy++)
	for (int iz=0; iz<Nz; iz++)
	  fprintf (fout, "  (%23.16e, %23.16e)\n",
		   FFT.rBox(ix,iy,iz).real(), FFT.rBox(ix,iy,iz).imag());
  }
  else {
    fprintf (fout, "Real blip coefficients for extended orbital\n");
    realNorm2 = 0.0; imagNorm2 = 0.0;
    for (int ix=0; ix<Nx; ix++)
      for (int iy=0; iy<Ny; iy++)
	for (int iz=0; iz<Nz; iz++) {
	  realNorm2 += FFT.rBox(ix,iy,iz).real()*FFT.rBox(ix,iy,iz).real();
	  imagNorm2 += FFT.rBox(ix,iy,iz).imag()*FFT.rBox(ix,iy,iz).imag();
	}
    if (realNorm2 > imagNorm2) 
      for (int ix=0; ix<Nx; ix++)
	for (int iy=0; iy<Ny; iy++)
	  for (int iz=0; iz<Nz; iz++) {
	    // Removing phase factor for now
	    complex<double> wfVal = /* factor * */ FFT.rBox(ix,iy,iz);
	    fprintf (fout, "  %23.16e\n", wfVal.real());
	    //	  fprintf (fout, "  %23.16e\n", FFT.rBox(ix,iy,iz).real());
	  }
    else
      for (int ix=0; ix<Nx; ix++)
	for (int iy=0; iy<Ny; iy++)
	  for (int iz=0; iz<Nz; iz++) {
	    // Removing phase factor for now
	    complex<double> wfVal = /* factor * */ FFT.rBox(ix,iy,iz);
	    fprintf (fout, "  %23.16e\n", wfVal.imag());
	  }
  }
}

bool
PlaneWaveSystem::WriteBWFN(string name)
{
  CellClass &cell = WriteSuper ? SuperCell : PrimCell;
  TinyVector<Array<OrbitalClass*,2>,2> &orbs =
    WriteSuper ? SuperOrbitals : Orbitals;
  FFTBox &FFT = cell.FFT;

  if (Comm.MyProc() != 0)
    return true;

  cell.SetupFFT();

  // Write complex orbitals if not at the gamma point
  bool writeComplex = orbs[0].extent(0) > 1;
  Vec3 k0 = orbs[0](0,0)->GetPrimk();
  writeComplex = writeComplex || (dot(k0,k0) > 1.0e-10);

  FILE *fout = fopen (name.c_str(), "w");
  if (fout == NULL)
    return false;
  WriteCasinoHeader (fout);
  fprintf (fout, "Blip Grid\n");
  int nx, ny, nz;
  FFT.GetDims (nx, ny, nz);
  fprintf (fout, "%4d %4d %4d\n", nx, ny, nz);
  fprintf (fout, "\n");
  fprintf (fout, "WAVE FUNCTION\n-------------\n");
  fprintf (fout, "Number of k-points\n");
  int numk = orbs[0].extent(0);
  int numBands[2];
  numBands[0] = orbs[0].extent(1);
  numBands[1] = orbs[1].extent(1);
  fprintf (fout, "    %d\n", numk);
  for (int ki=0; ki < numk; ki++) {
    Vec3 k = orbs[0](ki,0)->GetPrimk();
    // Flip the sign of the k-vectors back again when writing
    fprintf (fout, "k-point # ; # of bands (up spin/down spin) ; k-point coords (au)\n");
    fprintf (fout, "     %d     %d     %d  %20.15f %20.15f %20.15f\n",
	     ki+1, numBands[0], numBands[1], -k[0], -k[1], -k[2]);
    for (int spin=0; spin<2; spin++) {
      for (int band=0; band < numBands[spin]; band++) {
	fprintf (fout, "Band, spin, eigenvalue (au), localized\n");
	fprintf (fout, "    %3d    %3d    %20.16f %s\n", 
		 band+1, 1, orbs[spin](ki, band)->GetEigVal(),
		 orbs[spin](ki,band)->Center==NULL ? "F" : "T");
	orbs[spin](ki, band)->WriteBWFN(fout, writeComplex, WriteSuper);
      }
    }
  }

  fclose(fout);
  if (Localized) 
    WriteCentres();
  return true;
}

typedef TinyVector<int,4> Int4;

struct Int4less
{
  bool operator()(Int4 a, Int4 b) const
  {
    if (a[0] > b[0]) return false;
    if (a[0] < b[0]) return true;
    if (a[1] > b[1]) return false;
    if (a[1] < b[1]) return true;
    if (a[2] > b[2]) return false;
    if (a[2] < b[2]) return true;
    if (a[3] > b[3]) return false;
    if (a[3] < b[3]) return true;
    
    return false;
  }
};



bool
PlaneWaveSystem::WriteBWFN(string baseName, Int3 split)
{
  CellClass &cell = WriteSuper ? SuperCell : PrimCell;
  TinyVector<Array<OrbitalClass*,2>,2> &orbs =
    WriteSuper ? SuperOrbitals : Orbitals;
  FFTBox &FFT = cell.FFT;

  if (Comm.MyProc() != 0)
    return true;

  cell.SetupFFT();

  // Write complex orbitals if not at the gamma point
  bool writeComplex = orbs[0].extent(0) > 1;
  Vec3 k0 = orbs[0](0,0)->GetPrimk();
  writeComplex = writeComplex || (dot(k0,k0) > 1.0e-10);

  // Is the k-point mesh commensurate with the splitting factor?
  bool commensurate = 
    ((kPointMesh[0] % split[0]) == 0) &&
    ((kPointMesh[1] % split[1]) == 0) &&
    ((kPointMesh[2] % split[2]) == 0);
  if (!commensurate) {
    cerr << "The k-point mesh " 
	 << kPointMesh[0] << "x" << kPointMesh[1] << "x" << kPointMesh[2]
	 << " is not commensurate with the splitting factor " 
	 << split[0] << "x" << split[1] << "x" << split[2] << endl;
    abort();
  }
  
  Int3 newkMesh = (kPointMesh[0] / split[0], 
		   kPointMesh[1] / split[1], 
		   kPointMesh[2] / split[2]);
  perr << "Splitting into " << split[0]*split[1]*split[2] 
       << " files, each with a " 
       << newkMesh[0] << "x" << newkMesh[1] << "x" << newkMesh[2] 
       << " k-point mesh.\n";

  // A map which connects the Int3 k-point index and band to the
  // orbital.  We need one such map for each spin.  
  std::map<Int4,OrbitalClass*,Int4less> orbMap[2];
  // Create the map
  for (int spin=0; spin<2; spin++) {
    for (int ki=0; ki<orbs[spin].extent(0); ki++)
      for (int bi=0; bi<orbs[spin].extent(1); bi++) {
	// HACK HACK HACK
// 	Int3 index = orbs[spin](ki,bi)->GetIndex();
// 	Int4 i4 (index[0], index[1], index[2], bi);
// 	orbMap[spin][i4] = orbs[spin](ki,bi);
      }
  }
  
  // Now do an outer loop over k-points
  int numBands = orbs[0].extent(1);
  // The file index and k index;
  Int3 fIndex, kIndex;

  int fileNum = 0;
  for (fIndex[0]=0; fIndex[0]<split[0]; fIndex[0]++) 
    for (fIndex[1]=0; fIndex[1]<split[1]; fIndex[1]++) 
      for (fIndex[2]=0; fIndex[2]<split[2]; fIndex[2]++) {
	stringstream fname;
	fname << baseName << fileNum;
	FILE *fout = fopen (fname.str().c_str(), "w");
	if (fout == NULL)
	  return false;
	WriteCasinoHeader (fout);
	fprintf (fout, "Blip Grid\n");
	int nx, ny, nz;
	FFT.GetDims (nx, ny, nz);
	fprintf (fout, "%4d %4d %4d\n", nx, ny, nz);
	fprintf (fout, "\n");
	fprintf (fout, "WAVE FUNCTION\n-------------\n");
	fprintf (fout, "Number of k-points\n");
	int numk, numBands[2];
	numk = newkMesh[0]*newkMesh[1]*newkMesh[2];
	numBands[0] = orbs[0].extent(1);
	numBands[1] = orbs[1].extent(1);
	fprintf (fout, "    %d\n", numk);

	perr << "File number " << fileNum << ":\n";

	int kNum = 0;
	for (kIndex[0]=0; kIndex[0]<newkMesh[0]; kIndex[0]++)
	  for (kIndex[1]=0; kIndex[1]<newkMesh[1]; kIndex[1]++)
	    for (kIndex[2]=0; kIndex[2]<newkMesh[2]; kIndex[2]++) {
	      Int4 i4;
	      i4[0] = fIndex[0] + kIndex[0]*split[0];
	      i4[1] = fIndex[1] + kIndex[1]*split[1];
	      i4[2] = fIndex[2] + kIndex[2]*split[2];
	      i4[3] = 0;
	      Vec3 k = orbMap[0][i4]->GetPrimk();
	      fprintf (stderr, "  Writing k-vector (%8.5f, %8.5f, %8.5f )\n",
		       -k[0], -k[1], -k[2]);

	      fprintf (fout, "k-point # ; # of bands (up spin/down spin) ; k-point coords (au)\n");
	      fprintf (fout, "     %d     %d     %d  %20.15f %20.15f %20.15f\n",
		       kNum+1, numBands[0], numBands[1], -k[0], -k[1], -k[2]);
	      for (int spin=0; spin<2; spin++) {
		for (int band=0; band < numBands[spin]; band++) {
		  i4[3] = band;
		  fprintf (fout, "Band, spin, eigenvalue (au), localized\n");
		  fprintf (fout, "    %3d    %3d    %20.16f %s\n", 
			   band+1, 1, orbMap[spin][i4]->GetEigVal(),
			   orbMap[spin][i4]->Center==NULL ? "F" : "T");
		  orbMap[spin][i4]->WriteBWFN(fout, writeComplex, WriteSuper);
		}
	      }
	      kNum++;
	    }
	fclose (fout);
	fileNum++;
      }
  
// 	for (int ki=0; ki < numk; ki++) {
// 	  Vec3 k = orbs[0](ki,0)->Getk();
// 	  fprintf (fout, "k-point # ; # of bands (up spin/down spin) ; k-point coords (au)\n");
// 	  fprintf (fout, "     %d     %d     %d  %20.15f %20.15f %20.15f\n",
// 		   ki+1, numBands[0], numBands[1], k[0], k[1], k[2]);
// 	  for (int spin=0; spin<2; spin++) {
// 	    for (int band=0; band < numBands[spin]; band++) {
// 	      fprintf (fout, "Band, spin, eigenvalue (au), localized\n");
// 	      fprintf (fout, "    %3d    %3d    %20.16f %s\n", 
// 		       band+1, 1, orbs[spin](ki, band)->GetEigVal(),
// 		       orbs[spin](ki,band)->Center==NULL ? "F" : "T");
// 	      orbs[spin](ki, band)->WriteBWFN(fout, writeComplex);
// 	    }
// 	  }
// 	}
	
  
  return true;
}


bool
PlaneWaveSystem::WritePWFN(string name)
{
  CellClass &cell = WriteSuper ? SuperCell : PrimCell;
  TinyVector<Array<OrbitalClass*,2>,2> &orbs =
    WriteSuper ? SuperOrbitals : Orbitals;
  if (Comm.MyProc() != 0)
    return true;

  FILE *fout = fopen (name.c_str(), "w");
  if (fout == NULL)
    return false;
  WriteCasinoHeader (fout);
  fprintf (fout, "\n");
  fprintf (fout, "WAVE FUNCTION\n-------------\n");
  fprintf (fout, "Number of k-points\n");
  int numk = orbs[0].extent(0);
  int numBands[2];
  numBands[0] = orbs[0].extent(1);
  numBands[1] = orbs[1].extent(1);
  fprintf (fout, "    %d\n", numk);
  for (int ki=0; ki < numk; ki++) {
    Vec3 k = orbs[0](ki,0)->GetPrimk();
    fprintf (fout, "k-point # ; # of bands (up spin/down spin) ; k-point coords (au)\n");
    fprintf (fout, "     %d     %d     %d  %20.15f %20.15f %20.15f\n",
	     ki+1, numBands[0], numBands[1], -k[0], -k[1], -k[2]);
    for (int spin=0; spin<2; spin++) {
      for (int band=0; band < numBands[spin]; band++) {
	if (orbs[spin](ki,band)->Center != NULL) {
	  CenterClass &center = *orbs[spin](ki,band)->Center;
	  Vec3 r = center.r;
	  fprintf (fout, "Band, spin, eigenvalue (au), centre, radius, orb, norm^2\n");
	  // Note, I believe the "1" after the radius specifies
	  // spherical localization
	  fprintf (fout, "    %3d    %3d    %20.16f  %23.16e %23.16e %23.16e %23.16e %d %23.16e\n", 
		   band+1, 1, orbs[spin](ki, band)->GetEigVal(),
		   r[0], r[1], r[2], center.Radius, 1, 
		   orbs[spin](ki,band)->GetNorm2());
	}
	else {
	  fprintf (fout, "Band, spin, eigenvalue (au)\n");
	  fprintf (fout, "    %3d    %3d    %20.16f\n", 
		   band+1, 1, orbs[spin](ki, band)->GetEigVal());
	}
      
	fprintf (fout, "Eigenvector coefficients\n");
	zVec orbCoefs = orbs[spin](ki,band)->GetCoefs();
	for (int Gi=0; Gi<orbCoefs.size(); Gi++) 
	  /// It seems CASINO format uses opposite convention for FFTs
	  /// than we do.  Therefore, we must conjugate coefficients.
	  /// Note we no longer conjugate on reading, since we just
	  /// flip the sign of the G-vectors and k-vectors instead.
	  fprintf (fout, "  (%23.16e,%23.16e)\n", orbCoefs(Gi).real(), orbCoefs(Gi).imag());
      }
    }
  }
  fclose(fout);
  
  if (Localized) 
    WriteCentres();

  return true;
}


void
PlaneWaveSystem::WriteCentres()
{
  CellClass &cell = WriteSuper ? SuperCell : PrimCell;

  if (Comm.MyProc() != 0)
    return;
  FILE *fout = fopen ("centres.dat", "w");
  assert (fout != NULL);
  fprintf (fout, "Number of centres\n %d\n", Centers.size());
  fprintf (fout, "Display coefficients of linear transformation (0=NO; 1=YES)\n");
  fprintf (fout, " 1\n");
  fprintf (fout, "Use spherical (1) or parallelpiped (2) localization regions\n");
  fprintf (fout, " %d\n", Centers[0].Spherical ? 1 : 2);
  fprintf (fout, " x, y, & z coords of centres ; radius ; no. orbs on centre (up & dn)\n");
  for (int i=0; i<Centers.size(); i++)
    fprintf (fout, " %23.16e %23.16e %23.16e %23.16e %d %d\n",
	     Centers[i].r[0], Centers[i].r[1], Centers[i].r[2],
	     Centers[i].Radius, Centers[i].NumUp, Centers[i].NumDown);
  fprintf (fout, "Minimum skin thickness (a.u.)\n");
  fprintf (fout, "  %1.8e\n", SkinThickness);
  fclose (fout);
}
