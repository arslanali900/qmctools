#include "OrbitalSetClass.h"
#include "ParserClass.h"
#include <Common/MPI/Communication.h>

bool
OrbitalSetClass::ReadRunInfo (ParserClass &parser)
{
  if (!parser.FindToken ("Generated by:\n"))        return false;
  if (!parser.ReadLine(GeneratedBy))                return false;
  if (!parser.FindToken ("Method:"))                return false;
  if (!parser.ReadWord (Method))                    return false;
  if (!parser.FindToken("DFT Functional:\n"))       return false;
  if (!parser.ReadLine(Functional))                 return false;
  if (!parser.FindToken ("Pseudopotential"))        return false;
  if (!parser.FindToken ("\n"))                     return false;
  if (!parser.ReadLine (Pseudopotential))           return false;
  if (!parser.FindToken ("Plane wave cutoff (au)")) return false;
  if (!parser.ReadDouble (ECut))                    return false;
  if (!parser.FindToken ("Spin polarized:"))        return false;
  string tmp;
  if (!parser.ReadWord (tmp))                       return false;
  if ((tmp==".false.") || tmp=="F") 
    SpinPolarized = false;
  else if ((tmp==".true.") || (tmp=="T"))
    SpinPolarized = true;
  else {
    perr << "Unrecognized boolean string " << tmp << " in ReadRunInfo.\n";
    abort();
  }
  if (!parser.FindToken ("Total energy"))           return false;
  if (!parser.FindToken ("\n"))                     return false;
  if (!parser.ReadDouble (TotalEnergy))             return false;
  if (!parser.FindToken ("Kinetic energy"))         return false;
  if (!parser.FindToken ("\n"))                     return false;
  if (!parser.ReadDouble (KineticEnergy))           return false;
  if (!parser.FindToken ("Local potential energy")) return false;
  if (!parser.FindToken ("\n"))                     return false;
  if (!parser.ReadDouble(LocalPotEnergy))           return false;
  if (!parser.FindToken ("Non"))                    return false;
  if (!parser.FindToken ("local potential energy")) return false;
  if (!parser.FindToken ("\n"))                     return false;
  if (!parser.ReadDouble(NonlocalEnergy))           return false;
  if (!parser.FindToken ("Electron"))               return false;
  if (!parser.FindToken ("electron energy"))        return false;
  if (!parser.FindToken("\n"))                      return false;
  if (!parser.ReadDouble (eeEnergy))                return false;
  if (!parser.FindToken ("Ion"))                    return false;
  if (!parser.FindToken ("ion energy"))             return false;
  if (!parser.FindToken ("\n"))                     return false;
  if (!parser.ReadDouble (IonIonEnergy))            return false;
  if (!parser.FindToken ("Number of electrons per primitive cell"))
    return false;
  if (!parser.ReadInt (NumElectrons[0]))               return false;
  NumElectrons[0] = NumElectrons[1] = NumElectrons[0]/2;
  return true;
}

bool
OrbitalSetClass::ReadIonPos(ParserClass &parser)
{
  bool success = parser.FindToken ("GEOMETRY");
  if (!success) return false;
  success = parser.FindToken ("cell");
  if (!success) return false;
  int numAtoms;
  success = parser.ReadInt (numAtoms);
  cerr << "Found " << numAtoms << " atoms.\n";
  if (!success) return false;
  success = parser.FindToken ("(au)");
  if (!success) return false;

  PrimCell.IonPos.resize(numAtoms);
  PrimCell.AtomTypes.resize(numAtoms);
  for (int atom=0; atom<numAtoms; atom++) {
    success = parser.ReadInt(PrimCell.AtomTypes(atom));
    if (!success) return false;
    for (int i=0; i<3; i++) {
      success = parser.ReadDouble(PrimCell.IonPos(atom)[i]);
      if (!success) return false;
    }
  }
  fprintf (stderr,   "Atom Type           Position:\n");
  for (int atom=0; atom<numAtoms; atom++) {
    fprintf (stderr, "   %2d      %9.5f %9.5f %9.5f\n", 
	     PrimCell.AtomTypes(atom),
	     PrimCell.IonPos(atom)[0], PrimCell.IonPos(atom)[1], 
	     PrimCell.IonPos(atom)[2]);
  }
  fprintf (stderr, "\n");
  return true;
}

bool
OrbitalSetClass::ReadLattice(ParserClass &parser)
{
  bool success = parser.FindToken ("(au)");
  if (!success) return false;
  Mat3 Aprim;
  for (int i=0; i<3; i++)
    for (int j=0; j<3; j++) {
      success = parser.ReadDouble (Aprim(i,j));
      if (!success) return false;
    }
  fprintf (stderr, "Primitive lattice vectors:\n");
  for (int i=0; i<3; i++)
    fprintf (stderr, "  [ %9.6f %9.6f %9.6f ]\n", 
	    Aprim(i,0), Aprim(i,1), Aprim(i,2));

  PrimCell.SetLattice  (Aprim);
  Mat3 Asuper = TileMatrix*Aprim;
  SuperCell.SetLattice (Asuper);
  
  fprintf (stderr, "Superlattice vectors:\n");
  for (int i=0; i<3; i++)
    fprintf (stderr, "  [ %9.6f %9.6f %9.6f ]\n", 
	     Asuper(i,0), Asuper(i,1), Asuper(i,2));
  
  Mat3 recip = PrimCell.Lattice.GetRecip();
  fprintf (stderr, "Reciprocal lattice vectors:\n");
  for (int i=0; i<3; i++)
    fprintf (stderr, "  [ %9.6f %9.6f %9.6f ]\n", 
	    recip(i,0), recip(i,1), recip(i,2));
  fprintf (stderr, "\n");  
  return true;
}


bool
OrbitalSetClass::ReadGVecs(ParserClass &parser)
{
  int numG;
  bool success = parser.FindToken("G-vectors");
  if (!success) return false;
  success = parser.ReadInt (numG);
  if (!success) return false;
  success = parser.FindToken ("(au)");
  if (!success) return false;

  GVecsArray.resize(numG);
  GInts.resize(numG);

  for (int iG=0; iG<numG; iG++) {
    for (int dim=0; dim<3; dim++) {
      success = parser.ReadDouble (GVecsArray(iG)[dim]);
      // HACK HACK HACK
      GVecsArray(iG)[dim] *= -1.0;
      if (!success) return false;
    }
  }
  perr << "Read " << numG << " G-vectors.\n";

  // Now compute integer values.
  double TwoPiInv = 1.0/(2.0*M_PI);
  Vec3 a0 = PrimCell.Lattice.a(0);
  Vec3 a1 = PrimCell.Lattice.a(1);
  Vec3 a2 = PrimCell.Lattice.a(2);
  Vec3 b0 = PrimCell.Lattice.b(0);
  Vec3 b1 = PrimCell.Lattice.b(1);
  Vec3 b2 = PrimCell.Lattice.b(2);
  for (int iG=0; iG<numG; iG++){
    GInts(iG)[0] = (int)round(TwoPiInv*dot(GVecsArray(iG), a0));
    GInts(iG)[1] = (int)round(TwoPiInv*dot(GVecsArray(iG), a1));
    GInts(iG)[2] = (int)round(TwoPiInv*dot(GVecsArray(iG), a2));
    Vec3 G = (double)GInts(iG)[0]*b0 + (double)GInts(iG)[1]*b1 +
      (double)GInts(iG)[2]*b2;
    Vec3 diff = GVecsArray(iG) - G;
    if (dot(diff,diff) > 1.0e-12) 
      perr << "Error:  mag = " << dot(diff,diff) << endl;
  }

  // Check this to see if the FFT box sizes are commensurate.
  // PrimCell.GVecs.Set  ( PrimCell.Lattice.GetDirect(), GVecsArray, FFTFactor);
  // SuperCell.GVecs.Set (SuperCell.Lattice.GetDirect(), GVecsArray, FFTFactor);
  return true;
}

bool
OrbitalSetClass::ReadOrbitals(ParserClass &parser)
{
  if (!parser.FindToken("k-points")) return false;
  int numk, numUpBands, numDownBands, dummy;
  if (!parser.ReadInt (numk)) return false;
  if (!parser.FindToken("(au)")) return false;
  if (!parser.ReadInt (dummy)) return false;
  /// Number of up bands
  if (!parser.ReadInt (numUpBands)) return false;
  /// Number of down band -- not used if not spin-dependent
  if (!parser.ReadInt (numDownBands)) return false;

  PrimOrbitals[0].resize(numk, numUpBands);
  if (numDownBands > 0)
    PrimOrbitals[1].resize(numk,numDownBands);
  int numBands = numUpBands + numDownBands;
  for (int ik=0; ik<numk; ik++) {
    for (int iband=0; iband<numUpBands; iband++) {
      PrimOrbitals[0](ik,iband) = new OrbitalClass;
      PrimOrbitals[0](ik,iband)->SetCell (PrimCell);
      // PrimOrbitals[0](ik,iband)->SetPrimTwistIndex(ik);
    }
    for (int iband=0; iband<numDownBands; iband++) {
      PrimOrbitals[1](ik,iband) = new OrbitalClass;
      PrimOrbitals[1](ik,iband)->SetCell (PrimCell);
      // PrimOrbitals[1](ik,iband)->SetPrimTwistIndex(ik);
    }
  }

  parser.Reset();

  if (!parser.FindToken("k-points")) return false;

  Vec3 k;
  int kpoint, upbands, downbands, spin;
  double eigval;
  int numCoefs = GVecsArray.size();
  for (int ik=0; ik < numk; ik++) {
    if (!parser.FindToken("k-point"))          return false;
    if (!parser.FindToken("(au)"))             return false;
    if (!parser.ReadInt (kpoint))              return false;
    assert (kpoint == ik+1);
    if (!parser.ReadInt (upbands))             return false;
    assert (upbands == numUpBands); 
    if (!parser.ReadInt (downbands))           return false;
    assert (downbands == numDownBands);
    if (!parser.ReadDouble(k[0]))              return false;
    if (!parser.ReadDouble(k[1]))              return false;
    if (!parser.ReadDouble(k[2]))              return false;
    // HACK HACK HACK:  since we use the opposite FFT convention than
    // CASINO, k -> -k
    k = -1.0*k;
    int iband[2] = { 0, 0 };
    for (int band=0; band<numBands; band++) {
      if (!parser.FindToken ("Band"))          return false;
      if (!parser.FindToken ("\n"))            return false;
      if (!parser.ReadInt (dummy))             return false;
      if (!parser.ReadInt (spin))              return false;
      if (!parser.ReadDouble (eigval))         return false;
      if (!parser.FindToken ("\n"))            return false;
      if (!parser.FindToken ("coefficients"))  return false;
      // Make spin 0 or 1 instead 1 or 2
      spin--;
      OrbitalClass &orb = *(PrimOrbitals[spin](ik, iband[spin]));
      orb.SetLabels (spin, ik, iband[spin]);
      orb.SetCell (PrimCell);
      orb.Setk(k);
      orb.SetEigVal (eigval);
      if (!orb.Read (parser,numCoefs)) 
	return false;
      iband[spin]++;
    }
    // Gramm-Schmidt orthogonalize bands:
    for (int spin=0; spin<2; spin++) {
      int nBands = PrimOrbitals[spin].extent(1);
      for (int m=0; m<nBands; m++) { 
	zVec &mCoefs = PrimOrbitals[spin](ik, m)->GetCoefs();
	double nrm = 0.0;
	for (int i=0; i<mCoefs.size(); i++)
	  nrm += norm (mCoefs(i));
	mCoefs *= 1.0/sqrt(nrm);
	for (int n=m+1; n<nBands; n++) {
	  zVec &nCoefs = PrimOrbitals[spin](ik, n)->GetCoefs();
	  complex<double> overlap(0.0, 0.0);
	  for (int i=0; i<mCoefs.size(); i++) 
	    overlap += conj(mCoefs(i))*nCoefs(i);
	  if (norm(overlap) > 1.0e-12) 
	    cerr << "Serious nonorthogonality for m=" << m << ", n=" << n 
		 << "  overlap = " << overlap << endl;
	  //	   complex<double> overlap = conjdot (mCoefs, nCoefs);
	  nCoefs -= overlap * mCoefs;
	}
      }
    }
  }
				
  perr << "Successfully read " << numk << " kpoints by " 
       << numBands << " bands.\n";
  return true;
}

bool
OrbitalSetClass::Read(string fname)
{
  if (fname.find("WFK") != std::string::npos) {
    if (!Read_ABINIT_WFK(fname)) {
      perr << "Error reading ABINIT WFK file \"" << fname << "\".  Aborting.\n";
      abort();
    }
    cerr << "Finished reading ABINIT WFK file.\n";
  }
  else if (fname.find("1WF") != std::string::npos) {
    if (!Read_ABINIT_WF1(fname)) {
      perr << "Error reading ABINIT WF1 file \"" << fname << "\".  Aborting.\n";
      abort();
    }      
    cerr << "Finished reading ABINIT WF1 file.\n";
  }
  else if (fname.find("xml") != std::string::npos) {
    if (!Read_FPMD(fname)) {
      perr << "Error reading FPMD file \"" << fname << "\".  Aborting.\n";
      abort();
    }
    cerr << "Finished reading FPMD file.\n";
  }  
  else if (fname.find(".h5") != std::string::npos) {
    if (!Read_LAPW(fname)) {
      perr << "Error in reading LAPW file \"" << fname << "\".  Aborting.\n";
      abort();
    }
  }
  else if (!ReadPWFN(fname)) {
    perr << "Could not read file \"" << fname << "\".  Aborting.\n";
    abort();
  }
  return true;
}

bool 
OrbitalSetClass::ReadPWFN (string fname)
{
  if (Comm.MyProc() != 0)
    return true;
  MemParserClass memParser;
  FileParserClass2 fileParser;
  streamsize fsize = memParser.FileSize(fname);
  if (fsize == -1)
    return false;
  
  ParserClass *parserPtr;
  if (fsize < (streamsize)(1<<28))
    parserPtr = &memParser;
  else
    parserPtr = &fileParser;

  ParserClass &parser = *parserPtr;

  bool success;

  if (!parser.OpenFile (fname))         return false;
  perr << "Opened pwfn file.\n";
  if (!ReadRunInfo (parser)) {
    perr << "Error reading run info.\n";
    return false;
  }
  cerr << "Before ReadIonPos.\n";
  if (!ReadIonPos (parser))             return false;
  cerr << "Before ReadLattice.\n";
  if (!ReadLattice (parser))            return false;
  TileIonPos();
  cerr << "Before ReadGvecs.\n";
  if (!ReadGVecs (parser))              return false;
  if (!ReadOrbitals(parser))            return false;
  parser.CloseFile();

  // Setup the FFT indices
  SetupFFTIndices();
  // Now, create the supercell orbitals
  CreateSuperOrbitals();
  if (UseMultiRep)
    CreateFineOrbitals();
  
  return true;
}

void
OrbitalSetClass::SetupFFTIndices()
{
  int numPrimTwists = PrimOrbitals[0].extent(0);
  int numG = GVecsArray.size();
  Int3 maxFFTBox (0,0,0);
  Array<Vec3,2> superGs(numPrimTwists, numG);
  GVecsClass superGVecs;
  Mat3 Aprim  =  PrimCell.Lattice.GetDirect();
  Mat3 Asuper = SuperCell.Lattice.GetDirect();

  // First, find the maximum fft box size
  SuperGshifts.resize(numPrimTwists);
  for (int ik=0; ik<numPrimTwists; ik++) {
    Vec3 k = PrimOrbitals[0](ik,0)->Getk();
    Vec3 superTwist = SuperCell.Lattice.k2Twist (k);
    Vec3 intPart = Vec3 (round(0.999999*superTwist[0]), 
			 round(0.999999*superTwist[1]), 
			 round(0.999999*superTwist[2]));
    cerr << "superTwist = " << superTwist << endl;
    cerr << "intPart    = " << intPart << endl;
    // This is the component of the k-vector of the primitive lattice
    // that is a G-vector of the superlattice.
    SuperGshifts[ik] = SuperCell.Lattice.Twist2k(intPart);
    for (int ig=0; ig<GVecsArray.size(); ig++)
      superGs(ik,ig) = GVecsArray(ig) + SuperGshifts[ik];
    
    Array<Vec3,1> superGArray;
    superGArray.reference (superGs(ik,Range::all()));
    Int3 fftBox = superGVecs.GetFFTBoxSize(Asuper, superGArray, FFTFactor);
    for (int i=0; i<3; i++)
      maxFFTBox[i] = max(maxFFTBox[i], fftBox[i]);
  }
  cerr << "The max FFT box size is " << maxFFTBox << endl;

  // Create primitive indices
  PrimCell.GVecs.Set (Aprim, GVecsArray, FFTFactor);
  PrimFFTIndices.resize(numG);
  for (int ig=0; ig<numG; ig++)
    PrimFFTIndices(ig) = PrimCell.GVecs.Index(ig);
  // Set orbitals to indices
  for (int spin=0; spin<2; spin++) {
    for (int ik=0; ik<PrimOrbitals[spin].extent(0); ik++)
      for (int iband=0; iband<PrimOrbitals[spin].extent(1); iband++)
	PrimOrbitals[spin](ik,iband)->SetFFTIndices(PrimFFTIndices);
  }

  // Create fine FFT indices
  FineCell.GVecs.Set (Aprim, GVecsArray, 2.0);
  FineFFTIndices.resize(numG);
  for (int ig=0; ig<numG; ig++)
    FineFFTIndices(ig) = FineCell.GVecs.Index(ig);

  // Now, create all of the indices
  SuperCell.GVecs.Set (Asuper, GVecsArray, maxFFTBox);
  SuperFFTIndices.resize(numPrimTwists);
  for (int ik=0; ik<numPrimTwists; ik++) {
    SuperFFTIndices[ik].resize(numG);
    Array<Vec3,1> superGArray;
    superGArray.reference (superGs(ik,Range::all()));
    superGVecs.Set (Asuper, superGArray, maxFFTBox);
    for (int ig=0; ig<numG; ig++)
      SuperFFTIndices[ik](ig) = superGVecs.Index(ig);
  }

  // Finally, setup the GVecs
}


void
OrbitalSetClass::TileIonPos()
{
  int numAtoms = PrimCell.IonPos.size();
  // Now, tile the supercell
  int numSuper = (int)round(fabs(det(TileMatrix)))*numAtoms;
  vector<Vec3> superPos;
  vector<int>  superTypes, superZion;
  Int3 iMax(5,5,5);
  for (int i=0; i<3; i++) 
    for (int j=0; j<3; j++)
      iMax(i) = max(iMax(i), (int)round(fabs(TileMatrix(i,j))));
  for (int i0=-iMax[0]; i0<=iMax[0]; i0++)
    for (int i1=-iMax[1]; i1<=iMax[1]; i1++)
      for (int i2=-iMax[2]; i2<=iMax[2]; i2++) 
	for (int iat=0; iat<numAtoms; iat++) {
	  Vec3 r = PrimCell.IonPos(iat);
	  r += (double)i0*PrimCell.Lattice.a(0);
	  r += (double)i1*PrimCell.Lattice.a(1);
	  r += (double)i2*PrimCell.Lattice.a(2);
	  Vec3 uSuper = SuperCell.Lattice.r2u(r);
	  if ((uSuper[0] >= -1.0e-6) && (uSuper[0] < 0.9999) &&
	      (uSuper[1] >= -1.0e-6) && (uSuper[1] < 0.9999) &&
	      (uSuper[2] >= -1.0e-6) && (uSuper[2] < 0.9999)) {
	    superPos.push_back(r);
	    superTypes.push_back(PrimCell.AtomTypes(iat));
	    if (PrimCell.Zion.size() > iat)
	      superZion.push_back(PrimCell.Zion(iat));
	  }
	}
  cerr << "There are " << superPos.size() << " atoms in the supercell.\n";

  SuperCell.IonPos.resize(superPos.size());
  SuperCell.AtomTypes.resize(superPos.size());
  SuperCell.Zion.resize (superZion.size());
  fprintf (stderr, "Supercell atom positions (reduced coords):\n");
  for (int i=0; i<superPos.size(); i++) {
    SuperCell.IonPos(i)    =   superPos[i];
    SuperCell.AtomTypes(i) = superTypes[i];
    if (SuperCell.Zion.size())
      SuperCell.Zion(i) = superZion[i];
    Vec3 uSuper = SuperCell.Lattice.r2u(superPos[i]);
    fprintf (stderr, "  %3d  %6.3f %6.3f %6.3f\n", 
	     superTypes[i], uSuper[0], uSuper[1], uSuper[2]);
  }
  cerr << endl;
  int numExpected = (int)round(fabs(det(TileMatrix)))*numAtoms;
  if (numExpected != superPos.size()) {
    cerr << "Expected " << numExpected << " atoms in the supercell, but found "
	 << superPos.size() <<".  Aborting.\n";
    abort();
  }

}


void
OrbitalSetClass::CreateSuperOrbitals()
{
  int maxSpin = SpinPolarized ? 1 : 0;
  double volRatio = SuperCell.Lattice.GetVolume() / PrimCell.Lattice.GetVolume();
  for (int spin=0; spin <= maxSpin; spin++) {
    cerr << "Creating super orbitals for spin " 
	 << (spin ? "up" : "down") << ":\n";
    // First, setup the primitive/super-orbital mapping
    TileMap[spin].CreateMap (PrimOrbitals[spin], PrimCell.Lattice, SuperCell.Lattice);

    // Now, create the superOrbitals
    int numTwists = TileMap[spin].GetNumSuperTwists();
    int numBands  = TileMap[spin].GetNumSuperBands();
    cerr << "# of super twists = " << numTwists 
	 << "   # of super bands = " << numBands << endl;
    SuperOrbitals[spin].resize(numTwists, numBands);
    for (int ik=0; ik<numTwists; ik++) 
      for (int iband=0; iband<numBands; iband++) {
	SuperOrbitals[spin](ik,iband) = new OrbitalClass;
	OrbitalClass &superOrb = *SuperOrbitals[spin](ik,iband);
	int primTwist, primBand;
	TileMap[spin].Super2Prim(ik,iband, primTwist, primBand);
// 	cerr << "(primTwist, primBand) = (" << primTwist << ", "
// 	     << primBand << ")\n";
	OrbitalClass &primOrb = *PrimOrbitals[spin](primTwist, primBand);
	
	superOrb.SetCell   (SuperCell);
	superOrb.SetCoefs  (primOrb.GetCoefs());
	superOrb.SetLabels (spin, ik, iband);
	superOrb.SetEigVal (volRatio * primOrb.GetEigVal());
	superOrb.SetFFTIndices (SuperFFTIndices[primTwist]);
	superOrb.SetGshift (SuperGshifts[primTwist]);
	Vec3 k = primOrb.Getk();
	Vec3 fracTwist = SuperCell.Lattice.k2Twist (k);
	for (int i=0; i<3; i++)
	  fracTwist[i] -= round(0.999999*fracTwist[i]);
	superOrb.SetTwist (fracTwist);
      }
  }

  // Setup super-GVecs
  int volFactor = (int)round(fabs(det(TileMatrix)));
  SuperGVecs.resize(SuperCell.GVecs.size()*volFactor);
  int ig=0;
  for (int i=0; i<SuperCell.GVecs.size(); i++) 
    for (int ik=0; ik<TileMap[0].GetNumPrimTwists(); ik++) {
      int superBand, superTwist;
      TileMap[0].Prim2Super (ik, 0, superTwist, superBand);
      if (superTwist==0) {
	OrbitalClass &superOrb = *SuperOrbitals[0](superTwist, superBand);
	Vec3 Gshift = superOrb.GetGshift();
	SuperGVecs(ig) = SuperCell.GVecs(i) + Gshift;
	ig++;
      }
    }
}


void
OrbitalSetClass::CreateFineOrbitals()
{
  int maxSpin = SpinPolarized ? 1 : 0;
  for (int spin=0; spin <= maxSpin; spin++) {
    cerr << "Creating fine orbitals for spin " 
	 << (spin ? "up" : "down") << ":\n";

    int numTwists = PrimOrbitals[spin].extent(0);
    int numBands  = PrimOrbitals[spin].extent(1);
    FineOrbitals[spin].resize(numTwists, numBands);
    for (int ik=0; ik<numTwists; ik++) 
      for (int iband=0; iband<numBands; iband++) {
	FineOrbitals[spin](ik,iband) = new OrbitalClass;
	OrbitalClass &fineOrb = *FineOrbitals[spin](ik,iband);
	OrbitalClass &primOrb = *PrimOrbitals[spin](ik,iband);
	fineOrb.SetCell   (FineCell);
	fineOrb.SetCoefs  (primOrb.GetCoefs());
	fineOrb.SetLabels (spin, ik, iband);
	fineOrb.SetEigVal (primOrb.GetEigVal());
	fineOrb.SetFFTIndices (FineFFTIndices);
	fineOrb.SetTwist (primOrb.GetTwist());
      }
  }
}




void
OrbitalSetClass::SetTileMatrix (Mat3 mat)
{
  TileMatrix = mat;
}

void
OrbitalSetClass::SetSkinThickness (double thickness)
{
  SkinThickness = thickness;
}

void
OrbitalSetClass::SetupMaps()
{
  UnitToHartreeMap[string("hartree")] = 1.0;
  UnitToHartreeMap[string("hartrees")] = 1.0;
  UnitToHartreeMap[string("Hartrees")] = 1.0;
  UnitToHartreeMap[string("rydberg")] = 0.5;
  UnitToHartreeMap[string("ev")]      = 0.03674932595264097934;
  
  UnitToBohrMap[string("bohr")]     = 1.0;
  UnitToBohrMap[string("atomic")]   = 1.0;
  UnitToBohrMap[string("angstrom")] = 1.8897261;

  // XCMap[XC_LDA] ="LDA" ; XCRevMap["LDA"] =XC_LDA;  XCRevMap["lda"] =XC_LDA;
  // XCMap[XC_GGA] ="GGA" ; XCRevMap["GGA"] =XC_GGA;  XCRevMap["gga"] =XC_LDA;
  // XCMap[XC_HF]  ="HF"  ; XCRevMap["HF"]  =XC_HF;   XCRevMap["hf"]  =XC_LDA;
  // XCMap[XC_DF]  ="DF"  ; XCRevMap["DF"]  =XC_DF;   XCRevMap["df"]  =XC_DF;
  // XCMap[XC_NONE]="NONE"; XCRevMap["NONE"]=XC_NONE; XCRevMap["none"]=XC_NONE;
  
  ZToSymbolMap[1]   = "H";  ZToSymbolMap[2]   = "He";
  ZToSymbolMap[3]   = "Li"; ZToSymbolMap[4]   = "Be";
  ZToSymbolMap[5]   = "B";  ZToSymbolMap[6]   = "C";
  ZToSymbolMap[7]   = "N";  ZToSymbolMap[8]   = "O";
  ZToSymbolMap[9]   = "F";  ZToSymbolMap[10]  = "Ne";
  ZToSymbolMap[11]  = "Na"; ZToSymbolMap[12]  = "Mg";
  ZToSymbolMap[13]  = "Al"; ZToSymbolMap[14]  = "Si";
  ZToSymbolMap[15]  = "P";  ZToSymbolMap[16]  = "S";
  ZToSymbolMap[17]  = "Cl"; ZToSymbolMap[18]  = "Ar";
  ZToSymbolMap[19]  = "K";  ZToSymbolMap[20]  = "Ca";
  ZToSymbolMap[21]  = "Sc"; ZToSymbolMap[22]  = "Ti";
  ZToSymbolMap[23]  = "V";  ZToSymbolMap[24]  = "Cr";
  ZToSymbolMap[25]  = "Mn"; ZToSymbolMap[26]  = "Fe";
  ZToSymbolMap[27]  = "Co"; ZToSymbolMap[28]  = "Ni";
  ZToSymbolMap[29]  = "Cu"; ZToSymbolMap[30]  = "Zn";
  ZToSymbolMap[31]  = "Ga"; ZToSymbolMap[32]  = "Ge";
  ZToSymbolMap[33]  = "As"; ZToSymbolMap[34]  = "Se";
  ZToSymbolMap[35]  = "Br"; ZToSymbolMap[36]  = "Kr";
  ZToSymbolMap[37]  = "Rb"; ZToSymbolMap[38]  = "Sr";
  ZToSymbolMap[39]  = "Y";  ZToSymbolMap[40]  = "Zr";
  ZToSymbolMap[41]  = "Nb"; ZToSymbolMap[42]  = "Mo";
  ZToSymbolMap[43]  = "Tc"; ZToSymbolMap[44]  = "Ru";
  ZToSymbolMap[45]  = "Rh"; ZToSymbolMap[46]  = "Pd";
  ZToSymbolMap[47]  = "Ag"; ZToSymbolMap[48]  = "Cd";
  ZToSymbolMap[49]  = "In"; ZToSymbolMap[50]  = "Sn";
  ZToSymbolMap[51]  = "Sb"; ZToSymbolMap[52]  = "Te";
  ZToSymbolMap[53]  = "I";  ZToSymbolMap[54]  = "Xe";
  ZToSymbolMap[55]  = "Cs"; ZToSymbolMap[56]  = "Ba";
  ZToSymbolMap[57]  = "La"; ZToSymbolMap[58]  = "Ce";
  ZToSymbolMap[59]  = "Pr"; ZToSymbolMap[60]  = "Nd";
  ZToSymbolMap[61]  = "Pm"; ZToSymbolMap[62]  = "Sm";
  ZToSymbolMap[63]  = "Eu"; ZToSymbolMap[64]  = "Gd";
  ZToSymbolMap[65]  = "Tb"; ZToSymbolMap[66]  = "Dy";
  ZToSymbolMap[67]  = "Ho"; ZToSymbolMap[68]  = "Er";
  ZToSymbolMap[69]  = "Tm"; ZToSymbolMap[70]  = "Yb";
  ZToSymbolMap[71]  = "Lu"; ZToSymbolMap[72]  = "Hf";
  ZToSymbolMap[73]  = "Ta"; ZToSymbolMap[74]  = "W";
  ZToSymbolMap[75]  = "Re"; ZToSymbolMap[76]  = "Os";
  ZToSymbolMap[77]  = "Ir"; ZToSymbolMap[78]  = "Pt";
  ZToSymbolMap[79]  = "Au"; ZToSymbolMap[80]  = "Hg";
  ZToSymbolMap[81]  = "Tl"; ZToSymbolMap[82]  = "Pb";
  ZToSymbolMap[83]  = "Bi"; ZToSymbolMap[84]  = "Po";
  ZToSymbolMap[85]  = "At"; ZToSymbolMap[86]  = "Rn";
  ZToSymbolMap[87]  = "Fr"; ZToSymbolMap[88]  = "Ra";
  ZToSymbolMap[89]  = "Ac"; ZToSymbolMap[90]  = "Th";
  ZToSymbolMap[91]  = "Pa"; ZToSymbolMap[92]  = "U";
  ZToSymbolMap[93]  = "Np"; ZToSymbolMap[94]  = "Pu";
  ZToSymbolMap[95]  = "Am"; ZToSymbolMap[96]  = "Cm";
  ZToSymbolMap[97]  = "Bk"; ZToSymbolMap[98]  = "Cf";
  ZToSymbolMap[99]  = "Es"; ZToSymbolMap[100] = "Fm";
  ZToSymbolMap[101] = "Mc"; ZToSymbolMap[102] = "No";
  ZToSymbolMap[103] = "Lw"; 

  ZToMassMap[  1] = 1.00794;
  ZToMassMap[  2] = 4.002602;
  ZToMassMap[  3] = 6.941;
  ZToMassMap[  4] = 9.012182;
  ZToMassMap[  5] = 10.811;
  ZToMassMap[  6] = 12.0107;
  ZToMassMap[  7] = 14.0067;
  ZToMassMap[  8] = 15.9994;
  ZToMassMap[  9] = 18.9984032;
  ZToMassMap[ 10] = 20.1797;
  ZToMassMap[ 11] = 22.98976928;
  ZToMassMap[ 12] = 24.3050;
  ZToMassMap[ 13] = 26.9815386;
  ZToMassMap[ 14] = 28.0855;
  ZToMassMap[ 15] = 30.973762;
  ZToMassMap[ 16] = 32.065;
  ZToMassMap[ 17] = 35.453;
  ZToMassMap[ 18] = 39.948;
  ZToMassMap[ 19] = 39.0983;
  ZToMassMap[ 20] = 40.078;
  ZToMassMap[ 21] = 44.955912;
  ZToMassMap[ 22] = 47.867;
  ZToMassMap[ 23] = 50.9415;
  ZToMassMap[ 24] = 51.9961;
  ZToMassMap[ 25] = 54.938049;
  ZToMassMap[ 26] = 55.845;
  ZToMassMap[ 27] = 58.933200;
  ZToMassMap[ 28] = 58.6934;
  ZToMassMap[ 29] = 63.546;
  ZToMassMap[ 30] = 65.39;
  ZToMassMap[ 31] = 69.723;
  ZToMassMap[ 32] = 72.61;
  ZToMassMap[ 33] = 74.92160;
  ZToMassMap[ 34] = 78.96 ;
  ZToMassMap[ 35] = 79.904;
  ZToMassMap[ 36] = 83.80;
  ZToMassMap[ 37] = 85.4678;
  ZToMassMap[ 38] = 87.62;
  ZToMassMap[ 39] = 88.90585;
  ZToMassMap[ 40] = 91.224;
  ZToMassMap[ 41] = 92.90638;
  ZToMassMap[ 42] = 95.94;
  ZToMassMap[ 43] = 98;
  ZToMassMap[ 44] = 101.07;
  ZToMassMap[ 45] = 102.90550;
  ZToMassMap[ 46] = 106.42;
  ZToMassMap[ 47] = 107.8682;
  ZToMassMap[ 48] = 112.411;
  ZToMassMap[ 49] = 114.818;
  ZToMassMap[ 50] = 118.710;
  ZToMassMap[ 51] = 121.760;
  ZToMassMap[ 52] = 127.60;
  ZToMassMap[ 53] = 126.90447;
  ZToMassMap[ 54] = 131.29;
  ZToMassMap[ 55] = 132.90545;
  ZToMassMap[ 56] = 137.327;
  ZToMassMap[ 57] = 138.9055;
  ZToMassMap[ 58] = 140.116;
  ZToMassMap[ 59] = 140.90765;
  ZToMassMap[ 60] = 144.24;
  ZToMassMap[ 61] = 145;
  ZToMassMap[ 62] = 150.36;
  ZToMassMap[ 63] = 151.964;
  ZToMassMap[ 64] = 157.25;
  ZToMassMap[ 65] = 158.92534;
  ZToMassMap[ 66] = 162.50;
  ZToMassMap[ 67] = 164.93032;
  ZToMassMap[ 68] = 167.26;
  ZToMassMap[ 69] = 168.93421;
  ZToMassMap[ 70] = 173.04;
  ZToMassMap[ 71] = 174.967;
  ZToMassMap[ 72] = 178.49;
  ZToMassMap[ 73] = 180.9479;
  ZToMassMap[ 74] = 183.84;
  ZToMassMap[ 75] = 186.207;
  ZToMassMap[ 76] = 190.23;
  ZToMassMap[ 77] = 192.217;
  ZToMassMap[ 78] = 195.078;
  ZToMassMap[ 79] = 196.96655;
  ZToMassMap[ 80] = 200.59;
  ZToMassMap[ 81] = 204.3833;
  ZToMassMap[ 82] = 207.2;
  ZToMassMap[ 83] = 208.98038;
  ZToMassMap[ 84] = 209;
  ZToMassMap[ 85] = 210;
  ZToMassMap[ 86] = 222;
  ZToMassMap[ 87] = 223;
  ZToMassMap[ 88] = 226;
  ZToMassMap[ 89] = 227;
  ZToMassMap[ 90] = 232.0381;
  ZToMassMap[ 91] = 231.03588;
  ZToMassMap[ 92] = 238.0289;
  ZToMassMap[ 93] = 237;
  ZToMassMap[ 94] = 244;
  ZToMassMap[ 95] = 243;
  ZToMassMap[ 96] = 247;
  ZToMassMap[ 97] = 247;
  ZToMassMap[ 98] = 251;
  ZToMassMap[ 99] = 252;
  ZToMassMap[100] = 257;
  ZToMassMap[101] = 258;
  ZToMassMap[102] = 259;
  ZToMassMap[103] = 262;
  ZToMassMap[104] = 261;
  ZToMassMap[105] = 262;
  ZToMassMap[106] = 263;
  ZToMassMap[107] = 262;
  ZToMassMap[108] = 265;
  ZToMassMap[109] = 266;
  ZToMassMap[110] = 269;
  ZToMassMap[111] = 272;
  ZToMassMap[112] = 277;
  ZToMassMap[113] = 284;
  ZToMassMap[114] = 289;
  ZToMassMap[115] = 288;
  ZToMassMap[116] = 293;
  ZToMassMap[117] = 293; // UNKNOWN
  ZToMassMap[118] = 294;

  for (int i=1; i<103; i++)
    SymbolToZMap[ZToSymbolMap[i]] = i;
}
